---
title: "genomicSimulation (v0.2.5) Vignette"
author: "Kira Villiers"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
      fig_caption: true
      number_sections: true
      toc: true
      #theme: simplex
vignette: >
  %\VignetteIndexEntry{genomicSimulation (v0.2.5) Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

**Significant changes in v0.2.5**:

- As part of efforts to increase naming consistency between R and C versions of the package, some R functions have changed names. The old function names still work, but may become deprecated at some point in future.

| Old name | New (recommended) name |
|:-----    | :----- |
| see.minimum.GEBV | see.minimal.GEBV |
| select.by.gebv | break.group.by.GEBV |
| make.group.from.label | break.group.by.label.value |
| make.group.from.label.range | break.group.by.label.range |
| make.label | create.new.label |
| load.more.genotypes | load.genotypes | 
| load.different.effects | load.effects |
| cross.randomly | make.random.crosses |
| cross.randomly.between | make.random.crosses.between |
| cross.combinations | make.targeted.crosses |
| cross.combinations.file | make.crosses.from.file |
| cross.dc.combinations.file | make.double.crosses.from.file |
| cross.all.pairs | make.all.unidirectional.crosses |
| save.local.GEBVs.by.file | save.local.GEBVs.blocks.from.file |
| save.local.GEBVs.by.chr | save.local.GEBVs.blocks.from.chrsplit |
	
See package's NEWS.md file for more detail and other changes.

```{r setup}
library(genomicSimulation)
```

# Introduction
genomicSimulation is a simple, fast scripting simulation tool for creating 'digital twins' of breeding schemes. The package tracks genotypes at an individual level, and performs stochastic simulation of meiosis (including crossing-over but not mutation) to simulate crossing.

All core functionality is written in C. Performing the computation-intensive tasks at C-level allows for quick runtimes. Because it was initially created for simulating plant breeding programs, the package does not automatically track sex.

Contact the package maintainers at https://github.com/vllrs/genomicSimulation/ for any feature requests or improvement requests, or to report any bug or crash. 

Guides on using the package can be found in sections 4 and 5 of this vignette.

[A formal writeup of this tool's design and performance is available on bioRxiv.](https://www.biorxiv.org/content/10.1101/2021.12.12.472291v2)

## Getting to know genomicSimulation

genomicSimulation exists as a set of scripting functions at R level (like `load.genotypes`, `cross.randomly`, and `see.optimal.haplotype`) plus an invisible table containing the simulation's currently-active data.

Broadly speaking, the tool provides three main categories of simulation functions:

- creating more genotypes, 
- selecting between genotypes,
- and reorganising/recategorising genotypes. 

Simulation functions can be used in any order and interspersed in any way. The only fixed requirement of a valid genomicSimulation script is that the first command is `load.data()`, which initialises the invisible table and loads the list of tracked genetic markers, which is the one un-changeable detail of a simulation. 

In genomicSimulation, every genotype is a member of a 'group', an abstract category represented by a number. Selection is simulated by pulling selected genotypes into a new group. Most crossing actions are performed using one group's members. Groups can be combined, split randomly, or split along specific lines. Groups can be deleted to destroy the genotypes they contain. 

Using these two factors (all genotypes being allocated to reconfigurable groups, and simulation actions being able to be undertaken in any order) genomicSimulation has the flexibility to simulate a huge range of breeding programs. You can imagine repeatedly simulating crosses from a 'breeding pool' group and discarding all but a selected subset of offspring which can be merged back into the breeding pool, or simulating a nucleus breeding system with several funneled breeding pools running simultaneously, each replenished by the best offspring of their own pool and whatever trickles down from more elite pools, or simulating a breeding program with concurrent population development/improvement streams which splits off copies of certain genotypes to repeatedly self into homozygosity for commercialisation testing.

As an R user, the functions `see.existing.groups()` and `see.group.data()` are the easiest ways to look at your simulation data, but more varied output formats are available via saving data to files.


# Speed
On a consumer-model laptop laptop (Intel(R) Core(TM) i5-7200U CPU @ 2.50GHz, 8GB RAM) running RStudio version 1.2.5019, the process of loading 50 founder lines and 5112 SNPs took on average 0.64 seconds.

A call to `make.random.crosses` to generate 100,000 ($10^5$) offspring from those founders took on average 2 seconds to run. Since all crossing functions use the same underlying meiosis simulation and same methodology, this time should be fairly representative of the speed of any crossing function. 

Output (writing to files) adds significant delays. The same command, with save-as-you-go output of GEBVs and pedigrees active, took approximately 20 seconds to run. With save-as-you-go output of GEBVs, pedigrees, and genotypes (genotypes in particular write a lot of characters to files), the function call took approximately 120 seconds. 

Generating the 100,000 offspring, then saving GEBVs, pedigrees, and genotypes to files via separate `save.` functions, took approximately 130 seconds to complete. This is a few seconds longer than the save-as-you-go call that did the same work, possibly because of the time spent moving from R-level execution to C-level and back again.

The C-level functions make no attempt to parallelise execution.

# Package-Specific Details
## Input Files

The first command run, to set up or reset the simulation, is `load.data`. This command takes up to three input files as parameters: a genotype matrix, a genetic map, and a list of marker effects. If multiple files are provided to `load.data`, the map file will be loaded first, followed by the genotype matrix and marker effect file.

### Genetic map files

The simplest genetic map file is formatted as follows:
```
marker chr pos
m3 3 15
m2 1 8.3
m1 1 5.2
```

The first column represents marker names. For all genomicSimulation features to work, genetic markers must have names. There is no issue with purely numeric names.

The second column represents the chromosome/linkage group in which that marker is found. Any alphanumeric combination may be used to denote a chromosome/linkage group, eg. '9' or '1A'.

The third column represents the position in centimorgans of that marker along that linkage group. (Distance of 1cM = expected probability of 0.01 chromosomal crossovers in that range.)

The header line is optional. However, if it is provided, the three columns "marker" "chr" and "pos" may be rearranged into any ordering. If the header is not provided, the order is assumed to be marker name, followed by chromosome, followed by position.

Cells may be separated by spaces, tabs, commas, or any combination thereof. Cell spacers do not need to be consistent across the file. 

The order in which genetic markers are presented in the file does not matter. If a marker is duplicated in the file, it will be recorded twice as two separate markers in the same position and with the same name. genomicSimulation does not check against this. However, if two markers have the same name, genotypes may not be loaded correctly, as loading genotypes depends on matching markers by name, so this should be avoided.

Other valid genetic map files might include:
```
chr marker pos
1A m1243509 173.2
1A m2350898 462.2
1B m4360992 32.009
2A m1243556 243.5
```
or
```
gene 10 3.24
othergene 10 8.3e-1
etc 15 1.203e2
```

### Genotype matrix files

The simplest genotype matrix file is formatted as follows:
```
name	G01	G02	G03	G04	G05	G06
m1	TT	TT	TT	TA	TT	AT
m3	TT	TT	TA	TA	TT	TT
m2	AA	AA	AA	AA	CC	AA
```
where G01, G02, ..., are names of the founder genotypes; m1, m2, ..., are the genetic markers; and entries in the matrix are the alleles that the founder genotypes have at those markers. 

The genotype matrix may be row-major or column-major (that is, the genetic markers may be rows, or columns). The program will determine the orientation by attempting to match row and column headers with names of markers tracked by the simulation. If the simulation does not yet have a list of tracked markers (that is, if this is the first file to be loaded, before even a genetic map file), then it defaults to assuming that columns represent genetic markers.  

Cells may be separated by spaces, tabs, commas, or any combination thereof. Cell spacers do not need to be consistent across the file. 

The order in which genetic markers are presented in the file does not matter. Genotypes, however, will be saved internally in the simulation in the order that they appear in the file. Genotype names need not be unique.

Marker names must be provided, so if the file does not have a header row, it must have a header column containing genetic marker names, and if it does not have a header column, it must have a header row containing genetic marker names.

The first or corner cell (in the above example, containing the value "name") can be deleted or can contain any text, which will be ignored. 

The simulation tool can parse a few different encodings of the alleles at each marker. The format of the allele pair will be automatically detected. All allele pairs in the same genotype matrix must be in the same format.

Allele pair encodings, with phase:

- Any pair of characters (see the above example). Alleles can be any character that is not a space, tab, comma, or newline.
- Any pair of characters, separated by a forwards slash "/" character. 

Allele pair encodings, without phase (the simulation tool will randomise phase of heterozygotes as the file is loaded):

- Alternate allele counts ("0", "1", "2"). If alternate allele counts are used, the reference allele is assumed to be T and the alternate allele A. ("0" then corresponds to "TT", "2" to "AA", and "1" will be randomised as either "TA" or "AT".) `change.allele.symbol` can be used after loading if you wish to change T and/or A to other symbols.
- IUPAC encodings ("G", "A", "T", "C", "R", "Y", "M", "K", "S", "W", "N")

**Note you might have a genotype matrix that uses "alternate allele counts"-style encoding but presents it in a format that looks like pairs of alleles, eg. "AA", "AT", and "TT".** genomicSimulation expects allele pair encodings to include haplotype phase, (that is, to have four possible values for genotypes of two alleles, not three: "AA", "AT", "TA", and "TT"). 

Two options for loading a dataset with non-phased "AA"/"AT"/"TT" allele pairs are:

- Use “haplotyping”/”haplotype phasing”/”haplotype inference” software to infer whether heterozygotes are "AT" or "TA", before loading into genomicSimulation.
- Find-and-replace "TT" with "0", "AT" with "1", and "AA" with "2" before loading into genomicSimulation. genomicSimulation will then randomise the phase of each haplotype.

Other valid genotype matrix files might include:
```
 m100, m101, m102
cand1,0,0,1
cand2,1,2,2
cand4,2,1,2
```
or
```
marker1	T/T	T/T	T/T	T/A	T/T	A/T
marker3	T/T	T/T	T/A	T/A	T/T	T/T
marker2	A/A	A/A	A/A	A/A	T/T	A/A
```

### Marker effect files

Loading effect file(s) is optional for running the simulation. The simplest marker effect file is formatted as follows:
```
marker allele eff
m1 A -0.8
m2 A -0.1
m3 A 0.1
m1 T 0.9
m3 T -0.1
```

The first column is to be a genetic marker name, corresponding to a name used in a previously-loaded map file. 

The second should be the allele (non-space character, eg "A") that this effect value corresponds to. 

The third should be a decimal representing the additive effect value of that allele for that marker.

The header line is optional. However, if it is provided, the three columns "marker" "allele" and "eff" may be rearranged. If the header is not provided, the order is assumed to be marker name, followed by allele symbol, followed by additive effect value. 

Cells may be separated by spaces, tabs, commas, or any combination thereof. Cell spacers do not need to be consistent across the file. 

The order in which rows are presented in the file does not generally matter. If a particular marker/allele combination is included multiple times in the file, only the last effect value in that file for that combination will be saved.

A particular marker/allele combination not being included in the file is equivalent to that combination having an effect value of 0. If a particular marker/allele combination is included multiple times in a file, only the last occurrence is saved. If a marker name in the file does not match any marker tracked by the simulation, that row will be ignored. The simulation will print out the number of marker/allele pairs for which effects are loaded: for the sample file above, that would be 5.

Other valid marker effect files might include:
```
marker eff allele
m1243509 0.1 A
m1243509 -0.1 T
m2350898 0.15 T
m2350898 -0.1 A
```
or
```
specialgene G 1.0
```

### Loading from other file formats
Updates to expand the range of allowed input formats are coming soon.


## The invisible table
The package has an internal invisible table (called `SimData`) where it stores simulated genotypes and other details. An external pointer to `SimData` is saved in a package-global R variable called `sim.data$p`. `sim.data$p` is hidden during regular use, and attempting to access the C-level data via the external pointer is not advised. All user-facing functions in the C library have R interfaces provided.

To reset the simulation/clear it of all data, the function `clear.simdata()` is provided. Currently the R version does not have functionality for having two concurrent simulation states in the same R session.

### Markers
The foundation of the `SimData` (that is, the only detail that cannot be changed without clearing the invisible table) is the list of genetic markers present in the map file (or the genotype file, if no map file was provided) passed to `load.data`. Only these markers will be tracked in simulation, even if later genotypes/maps/marker effects loaded mention other markers. 

Because the `SimData` stores its markers in genome order, any outputs produced will have the markers ordered according to the genetic map loaded at its creation. If an output method provides genotypes as strings of alleles, the string will also be ordered according to this genetic map.

Note that genomicSimulation does not care what potential values/alleles the marker can take. Any 8-bit non-space character will be accepted as an allele. This means SNP markers can be represented with the two alleles 0 and 1, or A and T, etc., according to your preference. On the other end of the spectrum, a marker could also represent an abstracted Mendelian gene with alleles A, a, t, +, and o. 

### Effects
The simulation calculates genetic breeding values for an arbitrary trait using an additive model.

While the simulation cannot run without a genetic map, it will happily run without effect values. There is no need to provide effect values if genetic breeding values are not to be used. If they are to be used, the simulation can load an effect file containing the additive effect of having a given allele at a given marker (see Indexes: Input File Formats: Effect files). The genetic breeding values are then calculated by adding up the effects of each allele in the genotype for which there is an effect loaded (that is, markers and alleles not mentioned in the effect file contribute nothing to the score).

Additional sets of marker effects can be loaded in with `load.different.effects()`. Each set of marker effects will have a numeric identifier (sequential natural numbers starting at 1), which is presented to the user as the return value from the function that loaded that effect file. All breeding value calculations will, by default, use the first loaded set of marker effects. The numeric identifier of a different set of marker effects can be passed to the `eff.set` parameter of these functions to use that marker effect set instead.

### Genotypes
Each genotype/line may or may not be given a name. Generating names for simulated genotypes can be turned on in the common crossing settings (see Indexes: Crossing Function Settings). 

You will likely want to load at least one genotype before starting simulation operations. genomicSimulation has no genome-construction or mutation mechanisms: there is no other way to get your simulation population started! At any point in simulation more genotypes can be imported from files using the function `load.genotypes`.

## Understanding Groups
As far as genomicSimulation is concerned, every genotype always exists as a member of a group. Genotypes loaded from the same file are automatically allocated to the same group. Every crossing function also places the genotypes it produces in a new group. Each group is denoted by a number.

A genotype can only belong to one group, so functions that overwrite allocations (eg `make.group`) effectively pull genotypes out of their old group and put them into the new one. This ensures that genotypes can only be deleted once.

Group numbers are natural numbers starting at 1. Group numbers are not guaranteed to be allocated sequentially, because some crossing functions may create and delete temporary groups to carry out their task, so the final group number could be 'out of order'. 

The group numbers of groups created or modified by a function call will be given in the return value of the function. In your R environment, the groups you are working with will be to all intents and purposes just integers. Note that only genomicSimulation functions can actually make changes to the groups. Modifying the numbers returned by genomicSimulation in the R environment will have no effect, and furthermore genomicSimulation will not, for example, delete a number in the R environment if that group ceases to exist.

## Understanding Custom Labels

Sometimes you might have reason to want to track extra details about your genotypes (a common use case would be the age or sex of the simulated individual), or you might want a categorisation system that persists even when groups are broken apart, dissolved, and/or reformed in efforts to perform particular selection or mating procedure.

A custom label is an attribute or field that is stable until changed by the user. genomicSimulation gives its users the power to create as many labels as desired, to set default values for each label, and to change the value of the label on each simulated individual.

Every genotype in the simulation will hold some value in every label that exists. Specifically, the values of the labels must be integers (whole numbers). Interpretation of the labels (e.g. age in months; year of birth; phenotype), is up to the user to keep track of: genomicSimulation only knows the ID of each label, and the values of that label for every simulated individual.

Like group numbers, label IDs are integers greater than 0. The function `make.label` returns the label ID of the label it just created. This is an exception to the usual rule that functions return the group number of the group that was created, or 0 if they did not create a new group. Label manipulation functions like `change.label.by.amount` do follow the pattern and return 0, since they do not create a new group. 

Also like groups, use `delete.label` to delete a custom label (all simulated individuals will still exist, but they will no longer have any value under the custom label that no longer exists). Merely removing the label ID from the R environment does nothing to remove the label from simulation memory.

## Understanding Identifiers
There are six categories of identifiers that may be observed during use of the simulation.

1. Group numbers/group IDs, which were discussed in the preceding section on groups. They are integers greater than 0 that define a set of genotypes/lines. Any number of lines can share a group number, and a line's group number may be changed over the course of the simulation.
1. Label IDs, which were discussed in the preceding section on labels. Like group numbers, they are integers greater than 0. They define a particular custom label. A label keeps its same identifier for its lifetime.  
1. Recombination Map IDs, which represent a particular genetic map/linkage map loaded in `load.data` or `load.map`. Like group numbers and label IDs, these identifiers are integers greater than 0.  A recombination map keeps its same identifier for its lifetime in the simulation (though, if you load the same recombination map multiple times, there could be multiple identical maps in the simulation, and once a map is deleted via `delete.recombination.map`, its ID may be reused).
1. Effect Set IDs, which represent a particular set of additive marker effects to be used for calculating breeding values. Each set of effects represents marker effects loaded from a single file in `load.data` or `load.effects`. Like group numbers and label IDs, these identifiers are integers greater than 0. A marker effect set keeps its same identifier for its lifetime in the simulation (though, if you load the same effect file multiple times, there could be multiple identical marker effect sets in the simulation, and once a set of marker effects is deleted via `delete.effect.set`, its ID may be reused).
1. Genotype Pedigree IDs. These are integers greater than 0 that are unique to a particular genotype for the lifetime of the simulation. IDs are used for tracking pedigree. However, genotypes are not guaranteed to have an ID: genotypes created during crossing with the setting `give.ids` set to FALSE will not be allocated IDs and will have 0 instead. 
1. Indexes. These represent the position/column number in the invisible table at which the genotype is stored. They are therefore unique to the genotype but not continuous over the lifetime of the simulation, because when genotypes/columns are deleted, the column numbers of the remaining genotypes may change. Because, unlike IDs, every genotype is guaranteed to have an index, functions like `make.group` and `make.targeted.crosses` that act on specific genotypes (rather than groups) generally take indexes as inputs. Since indexes can change, however, it is important to not place a `delete.group` call between getting index data and using indexes in one of these function calls.

The return values of nearly every function in the package (excluding the functions that pull data into R, whose names begin with `see.`) are vectors of integers representing one of the first four identifiers, above. If the function is `make.label`, it returns the new label's ID. If the function is `load.effects`, it returns the marker effect set ID from the provided effect file's set of marker effects. If the function is `load.map`, it returns the identifier for the recombination map just loaded. Most commonly, if the function created or modified groups, the return value(s) are the group number(s) of the group(s) created or modified. If the function returns 0, then it succeeded but did not change any groups.

## Understanding Output Methods
There are three sets of functions to get output from the simulation. 

- The first involves calling a function to save data to a file (`save.` family functions). These can be called on any group or on the entire simulation, cover a range of data types, each which has a few possible output formats (see Indexes: Output File Formats).
- The second involves saving the data about a cross at the same time as producing it (`save.` settings in crossing function parameters). This enables more compact data saving, and also allows for simulating more crosses than can be stored in working memory, by also setting the parameter `retain=FALSE`. In save-as-you-go saving, the simulation generates and saves crosses in batches of 1000 (This value could be changed by modifying the CONTIG_WIDTH setting (see Indexes: Global Settings Index)). save-as-you-go is however less flexible than `save.` family functions because only the default printing format is used and only the genotypes produced by that particular crossing call are saved.
- The third is to use the `see.` family of functions to pull data into R. These are the only functions that break the rule of function return values being either group numbers or 0 (see Understanding Groups). The custom selection method interface in R is designed to work with these functions (see Workflow: Writing Custom Selection Methods in R). 

See the indexes of this vignette for information on available functions and output formats. 

# Workflow
A simple workflow for this package could be:

1. Load progenitor lines and SNP data; save the group number of the progenitor lines. (The effect values for calculating breeding values for a desired trait can be loaded here too, if desired). Suggested function: `load.data`
1. Perform crossing from the progenitor group. Keep a hold of the group number of these crosses. Example function: `make.random.crosses`
1. Perform selection on the F1 generation generated above. Example function: `break.group.by.GEBV`
1. Perform more crossing from the F1 generation (using the group number from the above step).
1. Repeat for further generations.
1. Save the final genotypes (and/or effect values and/or pedigrees) to files. Example function: `save.genotypes`
1. (Optional: Estimate the number of crossovers to reach these final genotypes. Suggested function: `plot.crossovers`)
 Open output files for further analysis.

The example below shows a how a typical workflow would save group numbers and call crossing functions.
```{R}
# (Show the tiny example data set)
read.csv("../tests/testthat/helper_genotypes.txt", sep='\t', header=T)
read.csv("../tests/testthat/helper_map.txt", sep='\t', header=T)
read.csv("../tests/testthat/helper_eff.txt", sep='\t')

# Starting to use genomicSimulation: load the small initial data set
init <- load.data("../tests/testthat/helper_genotypes.txt",
                "../tests/testthat/helper_map.txt",
                "../tests/testthat/helper_eff.txt")
g0 <- init$groupNum
# eff1 <- init$effectID, the identifier of the effect file loaded, is the other entry in the list 'init'

# Do random crosses from the progenitor lines. 
f1 <- make.random.crosses(g0, n.crosses=20, give.names=TRUE, name.prefix="F1.")

#(Let's see what crossovers occured. For this few markers we don't get much information.)
save.pedigrees("a.txt", f1, type="P")
find.plot.crossovers("a.txt", "b.txt")

# Find the 25% with the top breeding value/GEBV
f1.selected <- break.group.by.GEBV(f1, percentage=25)

# Delete groups we are not currently using, to free up some memory.
delete.group(f1)

# Make 40 random crosses from those selected 25%
f2 <- make.random.crosses(f1.selected, n.crosses=5)
delete.group(f1.selected)

# Complete 4 rounds of selfing with save-as-you-go genotype saving
f6 <- self.n.times(f2, 4, file.prefix="af6", save.genotype=TRUE)

# Show current state of groups.
see.existing.groups()

# (These are the groups the above command should show)
print(c(g0, f2, f6))

# Show the save-as-you-go output file
read.csv("af6-genotype.txt", sep='\t')


# (cleanup)
file.remove("a.txt")
file.remove("b.txt")
file.remove("af6-genotype.txt")
```

## Tracking Sex of Genotypes

The above example, while not very realistic, was clearly inspired by plant breeding methods: four generations of selfing to produce a homozygous inbred fit for bulking and commercial release is not a usual strategy in animal breeding. Perhaps a key aspect in which animal breeding programs differ from a self-pollinated plant breeding program is that you can't cross just any animal with any other animal. That is referring, in part, to the higher importance of avoiding inbreeding, but mostly to the fact that animals come in male and female varieties.

genomicSimulation does not track sex of genotypes. The group system can however be used to that effect.

```{R}
# Starting to use genomicSimulation: load the small initial data set
init <- load.data("../tests/testthat/helper_genotypes.txt",
                "../tests/testthat/helper_map.txt",
                "../tests/testthat/helper_eff.txt")
cows <- init$groupNum
# Load the small initial data set again, pretending this represents a different set of genotypes
bulls <- load.genotypes("../tests/testthat/helper_genotypes.txt") 

# Create some offspring
f1 <- make.random.crosses.between(cows, bulls, n.crosses=5)

# Simulate the sex of offspring
temporary <- break.group.randomly(f1, into.n=2)
calvesF <- temporary[1]; calvesM <- temporary[2]; rm(temporary);

#... and so forth
```

Alternatively, a custom label could be used to track sex:

```{R}
# Starting to use genomicSimulation: load the small initial data set
init <- load.data("../tests/testthat/helper_genotypes.txt",
                "../tests/testthat/helper_map.txt",
                "../tests/testthat/helper_eff.txt")
cows <- init$groupNum
# Load the small initial data set again, pretending this represents a different set of genotypes
bulls <- load.genotypes("../tests/testthat/helper_genotypes.txt") 

# Define our interpretation of the custom label
FEMALE <- 1L
MALE <- 2L
# Create the label
sexLabel <- make.label(default=FEMALE)
change.label.to.this(sexLabel, MALE, group=bulls)

# Create some offspring
f1 <- make.random.crosses.between(cows, bulls, n.crosses=5)

# Simulate the sex of offspring
change.label.to.values(sexLabel, values=c(sample(c(FEMALE,MALE), size=5, replace=TRUE)), group=f1)

# Then split up your calves as needed
calvesF <- break.group.by.label.value(sexLabel, FEMALE, group=f1)
calvesM <- f1 #the calves left in F1 must be all the males

#... and so on
```

More sample scripts for simulating common scenarios using genomicSimulation can be found in [this Templates page](https://vllrs.github.io/genomicSimulationC/html/templates.html).


## Writing Custom Selection Methods in R
The only inbuilt selection method in genomicSimulation is `select.by.gebv`. However, custom selection methods can be written in R thanks to the `make.group` function, which takes an arbitrary set of indices and moves them into a new group. Indices of genotypes can be accessed via `see.group.data` with data type parameter `X`, operated on, then passed back to `make.group` to perform selection.

For an example, consider that a user wants to implement a custom selection method wherein they select the top 10 simulated crosses by phenotype. Because genomicSimulation offers no internal method for simulating phenotypes, the user must simulate them in R then use the custom selection method interface to perform their selection.

Suppose the user chooses the following model for their simulated phenotype. The phenotypic values will be made equal to the breeding value plus a draw for environmental variance from a normally distributed distribution with variance $V_e$, where $V_e$ comes from the equation $H^2 = V_g/(V_g + V_e)$. For the user's purposes, $H^2$ is a known broad-sense heritability estimate and $V_g$ is the variation in breeding values in the set of crosses from which they are selecting. Therefore, this approach uses the following steps to simulate phenotypes are: 
1. calculate the magnitude of $V_e$ using the set of breeding values from the crosses on which selection is being performed
2. draw from a normal distribution to get simulated phenotypes

The user creates the following R function to perform their selection:

```{R}
get.top.10.phenotypes <- function(group, heritability) {
  info <- data.frame(Index=see.group.data(group,"X"),
                     GEBV=see.group.data(group,"BV"))
  
  # simulate phenotype = genotype + environmental variation
  # using normally distributed Ve and heritability H^2 = (Ve + Vg)/Vg
  Vg <- var(info$GEBV)
  Ve <- Vg/heritability - Vg
  info$Pheno <- info$GEBV + rnorm(length(info$GEBV), mean=0, sd = sqrt(Ve))
  
  # Select those with the top phenotype
  return( info[order(info$Pheno, decreasing=TRUE),]$Index[1:10] )

}
```

and uses it via the make.group interface:
```{R}
init <- load.data("../tests/testthat/helper_genotypes.txt",
                "../tests/testthat/helper_map.txt",
                "../tests/testthat/helper_eff.txt")
g0 <- init$groupNum

# Simulate crosses
f1 <- make.random.crosses(g0, n.crosses=15, offspring=3)
# Apply custom selection method
f1.selected <- make.group(get.top.10.phenotypes(f1, 0.3))
# (delete the non-selected genotypes)
delete.group(f1)

# ... repeat for further generations
f2 <- make.random.crosses(f1.selected, n.crosses=100)
f2.selected <- make.group(get.top.10.phenotypes(f2, 0.5))

# ...
delete.group(c(f1.selected,f2,f2.selected))
```

The [writeup on bioRxiv](https://www.biorxiv.org/content/10.1101/2021.12.12.472291v2) includes the simulation results of a sample breeding program similar to this concept. 

# Details and Methodology

## Methodology: Calculating Breeding Values
The terms 'breeding value', 'genetic breeding value' and 'GEBV' (Genetic Estimated Breeding Value) are used interchangeably in the package, because the simulation is ignorant of whether real or estimated breeding values were loaded.

The package's internal GEBV calculator uses an additive model of trait effects. The additive effect values loaded from an input file (either via the `load.data` or the `load.different.effects` functions) are stored as a vector for each allele. In calculating breeding values for a genotype, the simulation counts how many copies of each particular allele the genotype has at each SNP, then multiples the vector of counts for a particular allele by the effects for that allele. The final result is the sum of these products across all alleles for which it has a stored effect vector.

![Diagram of the breeding value calculation process.](bvcalculation.png){width=100%}


## Methodology: Simulating Meiosis
To create a cross, the simulation generates gametes independently for the two parents. No distinction is made between male and female parent. Simulation of meiosis is also independent between crosses - the second gamete produced by simulation of meiosis is discarded, not saved for later.

For each chromosome number, the number of crossovers to occur in the simulated meiosis are drawn from a Poisson distribution with parameter = [length of the chromosome in Morgans], where length of the chromosome is the distance between the first and last SNP tracked by the linkage map that are on that chromosome. The positions of those crossovers along the chromosome are then drawn from a uniform distribution, which is why the use of a linkage map (so that distances correspond to likelihood of crossover) is recommended over use of a physical map. Finally, a random logical value (0 or 1) is drawn to choose which of the parent's chromosomes to start with (which of the two gametes produced to use). 

Note that this means that allele order in parents matters, and the simulate genotypes that are produced are phased. <!--Encoded data loaders like `load_transposed_encoded_genes_to_simdata` randomise the order of alleles when the line is heterozygous at a SNP on loading.-->

The R package uses the R random generators, so will follow the R seed.

<!--![Random draws for each chromosome](meiosisdists.png){width=100%}
![Using those random values to generate a gamete](meiosis.png){width=100%}-->

![Diagram of meiosis simulation process.](meiosis.png){width=100%}


## Methodology: Counting Recombinations
Extra functionality is available for estimating where crossovers occured in producing certain genotypes. This is offered by the `find.crossovers` and `find.plot.crossovers` functions. The difference between the two is that after crossovers points are found, as well as saving the results matrix to a file `find.plot.crossovers` produces an R plot, as shown below. It assumes the child is mostly homozygous.

![An example plot produced by the crossover finder function with certainty=FALSE. The lines plotted were produced by crossing the two parents then selfing for 6 generations. This produces a large number of crossover events.](crossovers.png){width=100%}

To identify crossovers, the code starts at the beginning of each chromosome for the current child line, and reads through to find SNPs where the parents differ. Here, the provenance of the child's genotype can be determined.

The functions have two parameters that affect the way the crossover counting works: `window.size` and `certainty`.

If the `certainty` setting is `True`, then SNPs where the provenance of an allele cannot be determined are marked with a 0, representing unknown parentage. If the `certainty` setting is `False`, when the provenance of an allele is unknown, the parentage at that SNP is set to the same parent as the most recent SNP with known parentage.

The `window.size` parameter should be an odd positive integer. The window size is the number of SNPs that are observed at a time. Only if the alleles of the child at all SNPs in the window represent a sequence that could have come from one parent, and that same sequence cannot have come from the other, is the parentage at that SNP considered known.

In developing this process it was considered that parent and child lines would be mostly homozygous. 

This functionality is very much untested and incomplete.

# Indexes
## Global Settings Index

- NAME_LENGTH (default 45).
- CONTIG_WIDTH (default 1000).

Generally, these default parameter settings should be satisfactory. If you do need to change them, add a line of the format `#define CONTIG_WIDTH 2048`, with your desired variable to modify and desired value to change it to, to the first line of `src/genomicSimulation-init.c`.

## Function Index
*Use the R documentation (eg. type `?load.data` in the RStudio console) to get descriptions of these functions.*

*There are square brackets around outputs to represent that they are placeholder names and can be replaced by any variable name of your choice.*

*The words in the brackets of each function convey the names of the parameters and their default values, if any. The function `load.data(allele.file, map.file, effect.file = NULL)` could be called as:*

- *`load.data(allele.file=[filename1], map.file=[filename2], effect.file=NULL)`, or*
- *`load.data(allele.file=[filename1], map.file=[filename2], effect.file=[filename3])`, or*
- *`load.data([filename1], [filename2])` (note that this call excludes parameter names, so the order of the filenames matters, and no value is provided for the third parameter, so the default value NULL will be used).*

*Many crossing functions are marked as having `[[settings]]` as a parameter. [[settings]] represents a shared set of optional parameters, described in * ***Section 6.3: Crossing Function Settings.***


Loading data:

- `[group] <- load.data(allele.file, map.file, effect.file = NULL)`
- If the effect file in `load.data` is not NULL, the return type is instead `list(groupNum=[group], effectID=[effect set])`
- `[group] <- load.genotypes(allele.file)`
- `[recombination map] <- load.map(map.file)`
- `[effect set] <- load.effects(effect.file)`

Simulating crossing:

- `[group] <- make.random.crosses(group,n.crosses,maps=0L,[[settings]])`
- `[group] <- make.random.crosses.between(group1,group2,cap1,cap2,n.crosses,map1=0L,map2=0L,[[settings]])`
- `[group] <- make.targeted.crosses(first.parents,second.parents,map1=0L,map2=0L,[[settings]])`
- `[group] <- make.crosses.from.file(cross.file,map1=0L,map2=0L,[[settings]])`
- `[group] <- make.double.crosses.from.file(cross.file,map1=0L,map2=0L,[[settings]])`
- `[group] <- make.all.unidirectional.crosses(group,map=0L,[[settings]])`
- `[group] <- self.n.times(group,n,map=0L,[[settings]])`
- `[group] <- make.doubled.haploids(group,map=0L,[[settings]])`
- `[group] <- make.clones(group,inherit.names,[[settings]])`

Manipulating custom labels:

- `[label] <- create.new.label(default)`
- `delete.label(labels)`
- `change.label.default(label, default)`
- `change.label.to.values(label, values, in group/no group, startIndex)`
- `change.label.to.this(label, value, in group(s)/no group)`
- `change.label.by.amount(label, amount, in group(s)/no group)`

Performing selection:

- `[selected.group] <- break.group.by.GEBV(from.group, low.score.best = FALSE, percentage OR number, eff.set=1L)`
- For more customised selection, use the process
  - `info <- data.frame("i" = see.group.data(from.group,"X"), "Data"=see.group.data(from.group,...))`
  - `selected.info <- `[some R manipulation on `info` that discards rows not selected under the custom selection]
  - `[selected.group] <- make.group(selected.info$i)`

Modify groupings:

- `[group] <- combine.groups(groups)`
- `[group] <- make.group(indexes)`
- `[group] <- break.group.by.label.value(label, value, in group(s)/no group)`
- `[group] <- break.group.by.label.range(label, rangeLowEnd, rangeHighEnd, in group(s)/no group)`
- `[vector of groups] <- break.group.into.individuals(group)`
- `[vector of groups] <- break.group.into.families(group)`
- `[vector of groups] <- break.group.into.halfsib.families(group)`
- `[vector of groups] <- break.group.evenly(group, into.n = 2)`
  - `[vector of groups] <- break.group.into.buckets(group, [vector of buckets])`
- `[vector of groups] <- break.group.randomly(group, into.n = 2)`
  - `[vector of groups] <- break.group.with.probabilities(group, [vector of probabilities])`

Save data (saves results to files):

- `change.allele.symbol(from, to, marker=NULL)`
- `change.names.to.values(values, group=NA)`

- `save.genotypes(filename, group = NULL, type = "R")`
- `save.allele.counts(filename, group = NULL, allele)`
- `save.pedigrees(filename, group = NULL, type = "R")`
- `save.GEBVs(filename, group = NULL, eff.set=1L)`
- `save.local.GEBVs.by.chr(filename, n.blocks.per.chr, group = NULL, eff.set=1L)`
- `save.local.GEBVs.by.file(filename, block.file, group = NULL, eff.set=1L)`

View data (pulls data into R dataframes):

- `[dataframe containing current existing groups and their sizes] <- see.existing.groups()`
- `[vector containing the chosen data] <- see.group.data(group, data.type, eff.set=1L)`
- `[string containing best allele at each SNP] <- see.optimal.haplotype(eff.set=1L)`
- `[string containing best allele that exists in the group at each SNP] <- see.optimal.possible.haplotype(eff.set=1L)`
- `[float: the maximum possible GEBV] <- see.optimal.GEBV(eff.set=1L)`
- `[float: the maximum possible GEBV from the pool of alleles that exist in the group] <- see.optimal.possible.GEBV(eff.set=1L)`
- `[float: the minimum possible GEBV] <- see.minimal.GEBV(eff.set=1L)`

Identify recombination events (experimental, not under current development):

- `find.crossovers(parentage.file, out.file, window.size = 1, certainty = TRUE)`
- `find.plot.crossovers(parentage.file, out.file, window.size = 1, certainty = TRUE)`

Data Storage:

- `clear.simdata()`
- `delete.group(groups)`
- `delete.recombination.map(maps)`
- `delete.effect.set(effect.sets)`

## Crossing Function Settings
All crossing functions take in a common set of settings. These are briefly described below.

- `offspring` : A setting representing the number of times to do each cross.
- `retain` : A boolean, repesenting whether to save the generated genotypes to memory or discard them. You may wish to discard them but save to file if you are generating too many crosses to save into memory.
- `give.names` : A boolean representing whether or not to produce names for the new genotypes generated. The names produced would have format [name.prefix][id]
- `name.prefix` : A string. If give.names is TRUE, the id is concatenated to this to produce the name of each new genotype.
- `track.pedigree` :A boolean representing whether or not to save the ids of the parents of each new genotype to the new genotype's pedigree. If this is false, the new genotype's pedigree is unknown.
- `give.ids` : A boolean representing whether or not to allocate each new genotype an id. If this is FALSE, the new genotype is 'invisible' to pedigree trackers and even if the pedigree of its offspring is supposedly tracked, the pedigree trackers will not be able to identify the progenitors of its offspring. Furthermore, if it is false and names are generated using give.names, all names generated in the same group will be the same. Probably you'd only have this FALSE if you were discarding the results or worried about id overflow.
- `file.prefix` : A string representing the prefix of files produced if save.pedigree=TRUE, save.gebv=TRUE, or save.genotype=TRUE.
- `save.pedigree` : A boolean. If TRUE, saves the pedigree in recursive format of each generated genotype to the text file with filename "[file.prefix]-pedigree".
- `save.gebv` : An integer. If 0, does not save GEBVs. If greater than 0, saves the GEBVs of each generated genotype to the tab-separated text file with filename "[file.prefix]-eff". The GEBVs will be calculated using the marker effect set whose identifier was given to this parameter.
- `save.genotype` : A boolean. If TRUE, saves the SNP/line matrix in regular format (generated genotypes as rows, SNPs as columns) to the tab-separated text file with filename "[file.prefix]-genome".

## Combination crossing functions
Two crossing functions (`make.crosses.from.file` and `make.double.crosses.from.file`) take instructions from files.

- `make.crosses.from.file` : Take a file containing tab-separated pairs of line names and perform those crosses. An example file looks like:
```
G01	G02
G01	G03
G05	G06
G01	G04
```
- `make.double.crosses.from.file` : Supposes that only the names of the precursor lines are known but specific crosses between F1 individuals are wanted. Assumes that those F1 individuals have been produced with id allocation/pedigree tracking turned on. The function therefore reads in a tab-separated file that looks like the below to perform the cross between the offspring of G01 and G02, and the offspring of G03 and G05, and so forth.
```
G01	G02	G03	G05
G01	G03	G05	G06
G05	G06	G01	G04
```


## Output File Formats
### Saving genotypes
Use the function `save.genotypes` or the `save.genotype = TRUE` setting of crossing functions to save the alleles of generated genotypes across the list of SNPs.

It will save genotypes in the following format:
```
	m1	m2	m3
F107	TT	AA	TT
F108	TT	AA	TT
F109	TA	AA	TT
```

Note that this is the transpose of the usual expected input file format. Due to the linked list method used to store genotypes, it will be slower/take more passes over the data to print the transposed equivalent. However, this alternate format (shown below) is available via `save.genotypes` with `type = "T"`.
```
   F107   F108   F109
m1 TT     TT     TA
m2 AA     AA     AA
m3 TT     TT     TT
```

If the members of a specific group are saved, rather than every genotype in the simulation, the output format will include the group number in the corner cell of the table. For example, if group 5 had members F107 and F108:
```
5	m1	m2	m3
F107	TT	AA	TT
F108	TT	AA	TT
```


### Saving pedigrees
Pedigrees can be saved in one of two ways:

- `save.pedigrees`, with `type = "P"`, which saves in the following format, even if grandparents are known:
```
F2010   F107   F107
F2011   F108   F109
```
This is a tab-separated text file. The first column is the child name, and the next two columns are the names of its immediate parents (or single parent duplicated if it was produced by selfing or doubling haploids). If names are not available, IDs are used instead. If parents are unknown, the columns will be blank. 

- `save.pedigrees`, with `type = "R"`, or crossing with setting `save.pedigree = TRUE`, which save in the following format:
```
10	F2010=(F107(G01,G02))
11	F2011=(F108(G01,G03),F109(G02,G03))
```
The function is recursive and will continue to track back to find parents until it reaches a genotype with unknown parentage. If, before it reaches a genotype with unknown parentage, it finds one with a parent that does not exist anymore (that has been deleted), it treats that genotype as having unknown parentage and also prints a warning to the user warning that they may have prematurely deleted some genotypes. Users who did intend to perform that deletion and wish to avoid this warning should turn ID allocation off when generating those to-be-deleted genotypes.

Note that in the example above, F2010 is produced by selfing or doubling a haploid of F107, while F2011 is a cross.

### Saving breeding values
Saving GEBVs, either via the `save.GEBVs` function or the `save.gebv = TRUE` setting of crossing functions, produces an output with the following format:
```
1	G01	1.400000
2	G02	1.400000
3	G03	1.600000
```
This is a tab-separated text file. The first column is the ID, then the name of each line, then the GEBV of that line.

### Saving block effect values/local GEBVs
The effect values for each parental half of a genotype's alleles and summed up for markers in a particular block (defined in the `block.file` parameter) can be saved to a file via the `save.local.GEBVs` function.

A block file with format the following format should be the second parameter:
```
Chrom	Pos	Name	Class	Markers
1	2.3	b000000	b	m1;m2;m3;
2 1.5 b000001 b m4;
...
```

The chromosome number, position and class columns are ignored. Any number of markers can be semicolon-separated in the last column. 

The output file has format:
```
    G1  G2  G3  G4 ...
b000000_1   0.25    0.25    -0.45   -0.45 ...
b000000_2   0.25    0.20    0.05    0.20 ...
b000001_1 ...
b000001_2 ...
```
This is a tab-separated text file.

### Save a summary of the `SimData`
The function `save.genome.model` is deprecated. A replacement will be developed.

### Recombination counters
The matrix saved to a file will have a format like the following:
```
	m1	m2	m3
F07	0	1	0
F08	0	2	0
F09	0	2	0
F10	0	1	0
```
A 0 refers to an unknown parentage. Non-zero values are the ID of the parent from which the allele was inherited. 


## R Output Formats

### `see.existing.groups`
This function returns a dataframe with two columns:

- `Group`, containing the group numbers of all existing groups
- `GroupSize`, containing the number of genotypes currently allocated to that group number.

### `see.group.data`
This function returns a vector containing the values of the chosen data type for each group member. The parameter `data.type` is case-insensitive and matched to the beginning of the string, so `data.type="N"` and `data.type="names"` both will return data of type 'N'.

Available data types: Description (`data.type` parameter value)

- Names (N)
- IDs (D)
- Indexes (X)
- Genotypes (G)
- GEBVs/breeding values (B). The additional parameter `effect.set` can be used to
select which set of marker effects to use to calculate the breeding values. It defaults to the first loaded set of effect values.
- Name of the first parent, or the first parent's ID if it has no name (P1)
- Name of the second parent, or the second parent's ID if it has no name (P2)
- Full/recursive known pedigree, as a string (PED)


